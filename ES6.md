## 1、变量声明 let const

> 相同点：
* 不存在变量提升，先声明后使用；
* 局部变量/块级作用域，且绑定当前作用域；
* 当前作用域内不允许重复声明；


```
块级作用域：用 {} 扩起来的内容为块级作用域，let、const 声明的变量仅在此作用域内有效；尽量避免在块级作用域内用函数声明式方法定义变量，此时的函数声明处理方式类似于var方式，会发生变量提升，但可以采用表达式的方式声明函数。
```
> 不同点：
* const 声明的为只读常量，声明的同时必须赋值，而且值不可改变；

```
const声明本质上不是变量的值不得改动，而是变量指向的那个内存地址不得改动；
```

> 总结：ES5声明变量的方法有两种：var function，ES6新增了let const import class。

## 2、解构赋值

> 定义：从数组和对象中提取值，对变量进行赋值。
* 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值，包括Set结构；
* 允许指定默认值，匹配的赋值对象只有严格等于undefined时默认值才会生效，默认值也可引用解构赋值的其他变量，但该变量必须已经声明；
* 惰性求值；
* 作为函数的参数也能解构赋值，同时函数的参数可指定默认值；

## 3、字符串扩展

>  通过{}扩展Unicode码点范围：原码点范围在\u0000~\uFFFF之间，超出这个范围的字符，必须用双字节的形式表示，导致这些单个字符串长度为2。

* codePointAt方法能正确返回32位的 UTF-16 字符的码点，识别范围超过charCodeAt方法

```
获得字符串编码  'str'.chartCodeAt(index)     'str'.codePointAt(index)
编码转字符串    String.fromCharCode('')      String.fromCodePoint('')
```

* for...of循环能正确识别32位的UTF-16字符的码点

## 4、正则

* 字符串可以使用正则的方法match()、replace()、search()和split()；
* 添加正则修饰符 u，用来处理大于\uFFFF的 Unicode 字符
* 添加正则修饰符 y，作用与g修饰符类似，也是全局匹配，但是必须从上一次匹配成功的下一个位置(起始)位置开始

```
注意标志符为全局 g
String.prototype.match 返回一个数组，数组的第一项是进行匹配完整的字符串，之后的项是与圆括号组合后捕获的结果。如果没有匹配到，返回null
RegExp.prototype.exec  返回一个数组，「并更新正则表达式对象的属性，下次从上个节点」，完全匹配成功的文本作为第一项，只用正则括号里的匹配项填充到数组后面
```

## 5、数组

> 空位处理：[,,,,]

ES6明确将空位转为undefined，ES6新增的方法也正确处理，包括：entries()、keys()、values()、find()、findIndex()、copyWithin()、fill()、Array.from、扩展运算符、for...of循环;   
ES5原有的方法forEach(), filter(), reduce(), every() 和some(）都做忽略空位处理，map()保留空位，join()和toString()会将空位视为undefined，而undefined和null最后会被处理成空字符串；  
空位处理方法不同，所以要尽量避免出现空位。

## 数值

* ES6二进制用前缀0b或0B表示，八进制数值用前缀0o或0O表示。
* 新增规范了一些方法